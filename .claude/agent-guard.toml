# Agent Guard Configuration
# Schema Version: 1.0
# Location: .claude/agent-guard.toml (project) or ~/.claude/agent-guard.toml (user)
#
# This file configures which destructive command patterns are detected by the
# agent guard system. Each pattern can be enabled/disabled and have custom
# denial messages.
#
# Configuration hierarchy:
# 1. ./.claude/agent-guard.toml (project-level overrides)
# 2. ~/.claude/agent-guard.toml (user-level defaults)
# 3. Embedded defaults (built into binary)

schema_version = "1.0"

[metadata]
source = "meta"
version = "0.1.0"
description = "Default agent guard patterns for meta CLI"

# Pattern Definitions
# Each pattern uses a namespaced ID (source.category.name) for forward compatibility
# with multi-tool pattern registration.

[[patterns]]
id = "meta.git.force_push"
priority = 100
enabled = true
matcher = { type = "regex", pattern = 'git\s+push.*(--force|-f)\b' }
validator = { type = "not_contains", value = "--force-with-lease" }
message = """
git push --force in a multi-repo workspace can overwrite history across \
multiple repos. Safer alternatives:
- git push --force-with-lease (checks for upstream changes)
- meta --include <repo> exec -- git push --force (target one repo)
- meta git snapshot create <name> before force pushing
"""

[[patterns]]
id = "meta.git.reset_hard"
priority = 100
enabled = true
matcher = { type = "regex", pattern = 'git\s+reset.*--hard\b' }
message = """
git reset --hard destroys uncommitted work. In a multi-repo workspace, \
this can silently discard changes across repos. Safer alternatives:
- meta git snapshot create <name> (save state first)
- meta git snapshot restore <name> (reversible reset)
- Target a specific repo: cd <repo> && git reset --hard
"""

[[patterns]]
id = "meta.git.clean_force"
priority = 100
enabled = true
matcher = { type = "regex", pattern = 'git\s+clean' }
validator = { type = "flags_present", command = "clean", flags = ["f", "d"] }
message = """
git clean -fd removes untracked files and directories permanently. \
In a multi-repo workspace, this affects all repos. Safer alternatives:
- git clean -nd (dry run — preview what would be removed)
- meta --include <repo> exec -- git clean -fd (target specific repos)
- meta git snapshot create <name> before cleaning
"""

[[patterns]]
id = "meta.git.checkout_dot"
priority = 100
enabled = true
# Matches "git checkout ." or "git checkout -- ."
matcher = { type = "regex", pattern = 'git\s+checkout\s+(--\s+)?\.(\s|$)' }
message = """
git checkout . reverts all modified files. In a multi-repo workspace, \
ensure you are in the correct repo directory. Safer alternatives:
- git checkout -- <specific-file> (target specific files)
- meta --include <repo> exec -- git checkout . (target one repo)
- meta git snapshot create <name> before reverting
"""

[[patterns]]
id = "meta.git.branch_force_delete"
priority = 100
enabled = true
matcher = { type = "regex", pattern = 'git\s+branch.*\s+-D\b' }
message = """
git branch -D force-deletes branches, potentially losing unmerged work. \
In a multi-repo workspace, this can affect coordination between repos. Safer alternatives:
- git branch -d <branch> (safe delete — only works if merged)
- git branch -v to check merge status first
- meta git snapshot create <name> before deleting
- meta --include <repo> exec -- git branch -D <branch> (target specific repos)
"""

[[patterns]]
id = "meta.git.stash_drop"
priority = 100
enabled = true
matcher = { type = "regex", pattern = 'git\s+stash\s+drop\b' }
message = """
git stash drop permanently removes a stash entry. \
For AI agents working across repos, this could discard important work. Safer alternatives:
- git stash list to review what will be dropped
- git stash show <stash> to inspect contents first
- git stash apply <stash> instead of pop (preserves the stash)
- meta git snapshot create <name> captures all stashes
"""

[[patterns]]
id = "meta.git.stash_clear"
priority = 100
enabled = true
matcher = { type = "regex", pattern = 'git\s+stash\s+clear\b' }
message = """
git stash clear removes ALL stash entries permanently. \
In a multi-repo workspace, this could discard important work across repos. Safer alternatives:
- git stash list to review what will be cleared
- git stash drop <stash> to remove specific entries one at a time
- meta git snapshot create <name> before clearing (captures all stashes)
- meta --include <repo> exec -- git stash clear (target specific repos)
"""

[[patterns]]
id = "meta.rm.dangerous_paths"
priority = 100
enabled = true
matcher = { type = "regex", pattern = 'rm\s+' }
validator = { type = "all_of", validators = [{ type = "flags_present", command = "rm", flags = ["r", "f"] }, { type = "args_match_any", command = "rm", values = [".", "..", "/", "~", "$HOME", ".meta", ".meta.yaml", ".meta.yml", "*", "./*", "../*", "./"] }] }
message = """
rm -rf on dangerous paths could destroy repo roots or workspace data. \
In a multi-repo workspace, this is especially dangerous. Safer alternatives:
- Remove specific files instead of entire directories
- meta --dry-run exec -- <cmd> to preview operations
- meta git snapshot create <name> before destructive operations
"""

# Examples: Project-specific overrides
#
# Disable a pattern:
# [[patterns]]
# id = "meta.git.checkout_dot"
# enabled = false
#
# Custom message:
# [[patterns]]
# id = "meta.git.force_push"
# enabled = true
# matcher = { type = "regex", pattern = 'git\s+push.*\s+(--force|-f)\b(?!-with-lease)' }
# message = "Our team policy: never force push to shared branches!"
